# Codebase Audit: Example Integrity Report

**Date:** November 30, 2025
**Auditor:** Gemini CLI Agent

---

## Executive Summary

A comprehensive audit of the `examples/` directory and `crates/*/examples` revealed a mixed state of integrity. While most examples are valid headless demonstrations of the core layout and widget engines, the flagship `showcase_gpu` example constitutes a **critical misrepresentation** (Category 1). It claims to be a WebGPU-accelerated WASM application but is implemented in the browser as pure JavaScript using HTML5 Canvas, with the Rust code serving only as a disconnected CLI simulation.

| Category | Count | Description | Status |
|----------|-------|-------------|--------|
| **1. Deceptive / "Potemkin"** | 1 | Rust/WASM disconnected from Web UI; UI faked in JS. | **CRITICAL FIX REQUIRED** |
| **2. Marketing Simulation** | 1 | Synthetic benchmarks explicitly designed to generate "10x" claims. | **Low Priority** (Label clearly) |
| **3. Valid Headless** | 20+ | Real engine code running in headless mode (SVG/Canvas recording). | **Pass** |
| **4. Valid Utilities** | 2 | Asset generators and tools. | **Pass** |

---

## Detailed Findings

### 1. Critical Integrity Issues (Deceptive)

#### `crates/presentar/examples/showcase_gpu.rs` + `web/showcase/index.html`
*   **Claim:** "Real WebGPU-accelerated visualization" (Source: `showcase_gpu.rs` docs).
*   **Reality:**
    *   **Rust:** The Rust code runs a physics simulation and prints coordinates to `stdout`. It has **no binding** to the DOM or WebGPU contexts.
    *   **Web:** `web/showcase/index.html` contains ~100 lines of **vanilla JavaScript** that re-implements the particle system (`class Particle`) and chart rendering logic using `CanvasRenderingContext2D`.
    *   **Inference:** The "Run Inference" button triggers a hardcoded JavaScript array rotation: `['Positive 94%', 'Negative 89%', 'Neutral 76%']`. It ignores the `.apr` model file entirely.
*   **Impact:** This nullifies all performance claims derived from the browser demo, as they measure V8 JavaScript performance, not Rust/WASM/WebGPU.

### 2. Marketing Simulations

#### `crates/presentar/examples/demo_10x_comparison.rs`
*   **Nature:** A synthetic benchmark.
*   **Methodology:** It simulates "Python overhead" by running busy-loops and `std::hint::black_box`, and compares this to "GPU work" simulated by integer addition loops.
*   **Verdict:** While technically "running code", the numbers are derived from arbitrary constants in the simulation (e.g., `simulate_python_overhead(10000)`), not actual framework comparisons.

### 3. Valid Headless Examples (Representative Sample)

These examples truthfully exercise the `presentar` layout and widget crates, producing either SVG output or debug info.

*   **`crates/presentar/examples/visual_demo.rs`**: **PASS**. Builds a widget tree, measures/layouts it using `presentar-layout`, and serializes the `RecordingCanvas` to a valid SVG file (`demo_output.svg`). This is a legitimate test of the engine.
*   **`crates/presentar/examples/dashboard.rs`**: **PASS**. Valid test of the widget tree and layout engine, reporting draw command counts.
*   **`crates/presentar/examples/cht_donut.rs`**: **PASS**. Valid CLI simulation that generates ASCII art. Honest about its nature.
*   **`crates/presentar/examples/yaml_manifest.rs`**: **PASS**. Valid demonstration of the configuration parsing logic.

### 4. Valid Utilities

*   **`crates/presentar/examples/generate_demo_assets.rs`**: **PASS**. Correctly uses `presentar-yaml` to serialize `.apr` and `.ald` binary formats.

---

## Recommendations

1.  **Immediate Action:** **Quarantine `showcase_gpu`**. Do not present it to external stakeholders as a "WebGPU" demo. Rename it to "Showcase Prototype (JS Implementation)" or delete the misleading HTML.
2.  **Remediation:**
    *   **Option A (Honesty):** Rewrite `index.html` to clearly state it is a "Concept Prototype".
    *   **Option B (Engineering):** Actually implement `wasm-bindgen` bindings in `showcase_gpu.rs` to expose the `ShowcaseDemo` struct to JS, and use `web-sys` to draw to the canvas from Rust.
3.  **Validation:** Add an integration test that verifies the WASM binary is actually loaded and executed by the web page (e.g., using `wasm-bindgen-test` in a headless browser).

---

*Report generated by Gemini CLI Agent.*
